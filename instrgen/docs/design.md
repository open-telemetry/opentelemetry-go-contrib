# OpenTelemetry Go Source Automatic Instrumentation - design

This document describes the design of `instrgen` - compile time automatic instrumentation for GO programming language.

## Background

Usually techniques used for instrumenting programs in specific languages are connected to runtimes and type systems
used by these languages and depend on capabilities offered by them. Methods differs depending on language properties.
Is executed by virtual machine? Is statically or dynamically typed?
What's matter is the injection point.
In dynamic languages it's very easy to replace original implementation by providing a new one
usually build on top of original one, a technique called monkey patching (look at python decorators).

GO is statically typed, natively compiled programming language which means that works on bare methal without
virtual machine in between. The only component that lives between your program and machine is operating system.
Therefore, to instrument GO programs, injection needs to be done at different level. There are two ways
utilized for now by opentelemetry community for GO:

1) an ebpf (https://ebpf.io/) a technology that allowes "programming" kernel 
   and can be used by native programming languages in general on platforms that provide it.
   
2) compile time instrumentation - used by `instrgen`

## Rationale

Compile time instrumentation is not different by other mechanisms described above.
The fundamental difference is the injection point, instrumentation has to be done 
at compile time which has cons and pros.

GO is perfect language for compile time instrumentation for two main reasons:
- everything what's needed is in standard library
- it's easy to control compilation process due to go compiler architecture

## Design

As mentioned above `instrgen` utilizes toolexec compiler switch (https://github.com/open-telemetry/opentelemetry-go-contrib/pull/4058/).

**NOTE** `driver` executable needs to be accessible via $PATH

### Flow
`instrgen` driver has two passes. First pass prepares some configuration for second pass based on provided settings,
it means that the same process is executed twice in different context.

It was designed and implemented this way to take input directly from user via command line switches and to do some
initial analysis, however this can be splitted into two separaate tools or processes.

`driver --inject  /testdata/basic yes main.main`

Executable takes few parameters:

1) command name
2) file pattern - determines files taken into instrumentation
3) yes/no - determines whether code should be injected in-place
4) entry point - a function from which injection process start

```sh
usage driver --command [file pattern] replace entrypoint
    command:
	inject                                 (injects open telemetry calls into project code)
	prune                                  (prune open telemetry calls
```

Below is the configuration generated by first pass and read by second one, when
driver is executed as go compiler plugin.

```json
{
"ProjectPath": ".",
"FilePattern": "/testdata/basic",
"Cmd": "inject",
"Replace": "yes",
"EntryPoint": {
    "Pkg": "main",
    "FunName": "main"
 }
}
```

First pass trigger the second one using following command:

```sh
go build -work -a -toolexec driver
```

### Instrumentation

`instrgen` has modular architecture and to add instrumentation for new package, 2 steps are needed,
implementation of specific `PackageRewriter` and its registration.

```go
// PackageRewriter interface does actual input package
// rewriting according to specific criteria.
type PackageRewriter interface {
        // ID Dumps rewriter id.
        Id() string
        // Inject tells whether package should be rewritten.
        Inject(pkg string, filepath string) bool
        // ReplaceSource decides whether input sources should be replaced
        // or all rewriting work should be done in temporary location.
        ReplaceSource(pkg string, filePath string) bool
        // Rewrite does actual package rewriting.
        Rewrite(pkg string, file *ast.File, fset *token.FileSet, trace *os.File)
        // WriteExtraFiles generate additional files that will be linked
        // together to input package.
        // Additional files have to be returned as array of file names.
        WriteExtraFiles(pkg string, destPath string) []string
}
```


#### Example rewriter

```go
// FunDumper rewrites all functions according to FilePattern.
type FunDumper struct {
}

// Id.
func (FunDumper) Id() string {
        return "FunDumper"
}

// Inject.
func (fd FunDumper) Inject(pkg string, filepath string) bool {
	return true
}

// ReplaceSource.
func (fd FunDumper) ReplaceSource(pkg string, filePath string) bool {
        return true
}

func makeStmts(name string) []ast.Stmt
	s := &ast.ExprStmt {
		X: &ast.CallExpr {
			Fun: &ast.SelectorExpr {
				X: &ast.Ident {
					Name: "__myfmt",
				},
				Sel: &ast.Ident {
					Name: "Println",
				},
			},
			Lparen: 42,
			Args: []ast.Expr {
				&ast.BasicLit {
					ValuePos: 43,
					Kind: STRING,
					Value: "\" + name +\"",
				},
			},
			Ellipsis: 0,
		},
	}
        return []ast.Stmt{s}

// Rewrite.
func (fd FunDumper) Rewrite(pkg string, file *ast.File, fset *token.FileSet, trace *os.File) {
        visited := make(map[string]bool, 0)
        ast.Inspect(file, func(n ast.Node) bool {
                if funDeclNode, ok := n.(*ast.FuncDecl); ok {
                        // check if functions has been already instrumented
                        if _, ok := visited[fset.Position(file.Pos()).String()+":"+funDeclNode.Name.Name]; !ok {
                                funDeclNode.Body.List = append(makeStmts(funDeclNode.Name.Name), funDeclNode.Body.List...)
                                astutil.AddNamedImport(fset, file, "__myfmt", "fmt")
                                visited[fset.Position(file.Pos()).String()+":"+funDeclNode.Name.Name] = true
                        }
                }
                return true
        })
}

// WriteExtraFiles.
func (FunDumper) WriteExtraFiles(pkg string, destPath string) []string {
        return nil
}
```

### UI

To lower usage barrier to user `instrgen` offers simple UI where instrumentations of specific functions and libraries
can be selected.

![image info](./instrgen.png)

### Context passing
